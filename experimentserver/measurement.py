from __future__ import annotations

import abc
import enum
import re
import threading
import typing
from datetime import datetime, timedelta

from experimentlib.data.unit import Quantity
from experimentlib.logging.classes import LoggedAbstract, Logged
from experimentlib.util.time import now

import experimentserver
from experimentserver.hardware.base.enum import HardwareEnum


# Type definitions
T_FIELD_NAME = str
T_FIELD_VALUE = typing.Union[str, int, float, bool, Quantity, timedelta]

T_DYNAMIC_FIELD = typing.Callable[['Measurement'], T_FIELD_VALUE]

T_TAG_NAME = str
T_TAG_VALUE = typing.Union[str, int, bool, datetime, timedelta, Quantity, HardwareEnum]

T_FIELD_MAP = typing.Mapping[T_FIELD_NAME, T_FIELD_VALUE]
T_DYNAMIC_FIELD_MAP = typing.MutableMapping[str, T_DYNAMIC_FIELD]
T_TAG_MAP = typing.Mapping[T_TAG_NAME, T_TAG_VALUE]


class MeasurementTargetRemappingException(experimentserver.ApplicationException):
    """ Error thrown when measurement remapping fails. """
    pass


class MeasurementSource(metaclass=abc.ABCMeta):
    """ Measurement sources are classes that generate Measurement objects. This interface is used to define a method
    for fetching a source name for Measurement generation. """
    @abc.abstractmethod
    def get_export_source_name(self) -> str:
        """

        :return:
        """
        pass


class Measurement(Logged):
    """ Measurements capture data generated by Hardware for processing/storage. They are generic structures that
    contain a number of fields, optional tags, a measurement type/classification, and a timestamp. Measurements may
    contain dynamic fields (calculated on initialisation) and inherit globally configured tags. Tags and dynamic fields
    are metadata which is held in a stack. The app_metadata stack may be pused to or pulled from as necessary. """

    metadata_global_lock = threading.RLock()

    _metadata_global_dynamic_fields: typing.MutableMapping[T_FIELD_NAME, T_DYNAMIC_FIELD] = {}
    _metadata_global_tags: typing.MutableMapping[T_TAG_NAME, T_TAG_VALUE] = {}

    _metadata_global_metadata_stack: typing.List[typing.Tuple[typing.Mapping[T_FIELD_NAME, T_DYNAMIC_FIELD],
                                                              typing.Mapping[T_TAG_NAME, T_TAG_VALUE]]] = []

    def __init__(self, source: MeasurementSource, measurement_group: MeasurementGroup, fields: T_FIELD_MAP,
                 timestamp: typing.Optional[datetime] = None,
                 dynamic_fields: typing.Optional[T_DYNAMIC_FIELD_MAP] = None,
                 tags: typing.Optional[T_TAG_MAP] = None):
        """ Create new Measurement.

        :param source:
        :param measurement_group:
        :param fields:
        :param timestamp: if None then now() is used
        :param dynamic_fields:
        :param tags:
        """
        Logged.__init__(self)

        self.source = source
        self.measurement_group = measurement_group
        self._fields: typing.Dict[str, typing.Any] = dict(fields)
        self.timestamp = timestamp or now()
        self._tags: typing.Dict[str, typing.Any] = {}

        dynamic_fields = dict(dynamic_fields) if dynamic_fields is not None else {}

        with self.metadata_global_lock:
            # Default to global tags
            self._tags.update(self._metadata_global_tags)

            # Fetch global dynamic fields
            dynamic_fields.update(self._metadata_global_dynamic_fields)

        # Overwrite with instance fields and tags
        if tags is not None:
            self._tags.update(tags)

        # Append source name to tags
        self._tags['hardware'] = self.source.get_export_source_name()
        self._tags['hardware_class'] = str(self.source.__class__)

        # Apply dynamic fields and tags
        for tag_key, tag_value in self._tags.items():
            if callable(tag_value):
                self._tags[tag_key] = tag_value()

        for field_key, field_callable in dynamic_fields.items():
            self._fields[field_key] = field_callable(self)

    def add_field(self, name: T_FIELD_NAME, value: T_FIELD_VALUE):
        """ TODO

        :param name:
        :param value:
        :return:
        """
        self._fields[name] = value

    def get_fields(self) -> T_FIELD_MAP:
        """ TODO

        :return:
        """
        return self._fields.copy()

    def add_tag(self, name: T_TAG_NAME, value: T_FIELD_VALUE):
        """

        :param name:
        :param value:
        :return:
        """
        self._tags[name] = value

    def add_tags(self, tags: T_TAG_MAP):
        """

        :param tags:
        :return:
        """
        self._tags.update(tags)

    def get_tags(self) -> T_TAG_MAP:
        """ TODO

        :return:
        """
        return self._tags.copy()

    @staticmethod
    def generate_source_hash(source: str, measurement_group: MeasurementGroup) -> int:
        """ TODO

        :param source:
        :param measurement_group:
        :return:
        """
        return hash((source, measurement_group))

    def get_source_hash(self) -> int:
        """ TODO

        :return:
        """
        return self.generate_source_hash(self.source.get_export_source_name(), self.measurement_group)

    def __getitem__(self, item):
        if item in self._fields:
            return self._fields[item]

        if item in self._tags:
            return self._tags[item]

        raise ValueError(f"{item} not a valid field or tag")

    def __str__(self) -> str:
        fields = {k: str(v) for k, v in self._fields.items()}
        tags = {k: str(v) for k, v in self._tags.items()}

        return f"Measurement(source={self.source.get_export_source_name()}, " \
               f"measurement_group={self.measurement_group}, fields={fields}, " \
               f"timestamp={self.timestamp.strftime('%Y-%m-%d %H:%M:%S')}, " \
               f"tags={tags})"

    @classmethod
    def add_global_dynamic_field(cls, name: str, callback: T_DYNAMIC_FIELD) -> typing.NoReturn:
        """ TODO

        :param name:
        :param callback:
        """
        with cls.metadata_global_lock:
            cls._metadata_global_dynamic_fields[name] = callback

            cls.logger().info(f"Registered global dynamic field {name} = {callback!r}")

    @classmethod
    def add_global_tag(cls, tag: str, value: T_TAG_VALUE) -> typing.NoReturn:
        """ TODO

        :param tag:
        :param value:
        """
        with cls.metadata_global_lock:
            cls._metadata_global_tags[tag] = value

            cls.logger().info(f"Registered global tag {tag} = {value!r}")

    @classmethod
    def add_global_tags(cls, tags: T_TAG_MAP) -> typing.NoReturn:
        """ TODO

        :param tags:
        """
        if len(tags) == 0:
            return

        with cls.metadata_global_lock:
            cls._metadata_global_tags.update(tags)

            cls.logger().info(f"Registered global tags {tags!r}")

    @classmethod
    def push_global_metadata(cls) -> typing.NoReturn:
        """ Pop metadata stack (save current metadata). """
        with cls.metadata_global_lock:
            cls._metadata_global_metadata_stack.append((dict(cls._metadata_global_dynamic_fields),
                                                        dict(cls._metadata_global_tags)))

            cls.logger().info(f"Pushed global tag stack (depth: {len(cls._metadata_global_metadata_stack)})")

    @classmethod
    def pop_global_metadata(cls) -> typing.NoReturn:
        """ Pop metadata stack (retrieve previous metadata). """
        if len(cls._metadata_global_metadata_stack) > 0:
            return

        with cls.metadata_global_lock:
            (cls._metadata_global_dynamic_fields, cls._metadata_global_tags) = cls._metadata_global_metadata_stack.pop()

            cls.logger().info(f"Popped global tag stack (depth: {len(cls._metadata_global_metadata_stack)})")

    @classmethod
    def flush_global_metadata(cls) -> typing.NoReturn:
        """ Clear metadata stack. """
        with cls.metadata_global_lock:
            if len(cls._metadata_global_metadata_stack) > 0:
                (cls._metadata_global_dynamic_fields,
                 cls._metadata_global_tags) = cls._metadata_global_metadata_stack.pop(0)
                cls._metadata_global_metadata_stack.clear()

                cls.logger().info(f"Flushed global tag stack")


class MeasurementTarget(metaclass=abc.ABCMeta):
    """ Measurement targets process or store Measurement objects. Measurement objects from one source may be remapped
    to a target as necessary, allowing some data to be stored in public/private databases. """

    # Default exporter name
    MEASUREMENT_TARGET_DEFAULT = 'default'

    # Lock
    _measurement_metadata_lock = threading.RLock()

    # List of all targets
    _measurement_target_list: typing.Dict[str, typing.List[MeasurementTarget]] = {}

    # Remapping of exporter sources to targets
    _measurement_target_remap: typing.List[typing.Tuple[typing.Pattern, str]] = []

    # Cache for measurements
    _measurement_cache: typing.Dict[int, Measurement] = {}

    def __init__(self, measurement_target_name: typing.Optional[str] = None, **kwargs):
        """ Instantiate a new ExporterTarget.

        :param measurement_target_name:
        """
        super().__init__(**kwargs)

        self._exporter_target_name = measurement_target_name or self.MEASUREMENT_TARGET_DEFAULT

        # Register self into list of target exporters
        with self._measurement_metadata_lock:
            if self._exporter_target_name in self._measurement_target_list:
                self._measurement_target_list[self._exporter_target_name].append(self)
            else:
                self._measurement_target_list[self._exporter_target_name] = [self]

    @classmethod
    def get_cached_measurement(cls, source: str, measurement_group: MeasurementGroup) -> typing.Optional[Measurement]:
        """ Fetch the last Measurement generated from a given source in a given MeasurementGroup.

        :param source:
        :param measurement_group:
        :return:
        """
        measurement_hash = Measurement.generate_source_hash(source, measurement_group)

        with cls._measurement_metadata_lock:
            if measurement_hash not in cls._measurement_cache:
                return None

            return cls._measurement_cache[measurement_hash]

    @classmethod
    def measurement_target_remap(cls, source: str, destination: str) -> typing.NoReturn:
        """ TODO

        :param source:
        :param destination:
        """
        # Compile regex pattern
        source = source.replace('*', '.*')
        source = re.compile(f"^{source}$")

        with cls._measurement_metadata_lock:
            cls._measurement_target_remap.append((source, destination))

    @abc.abstractmethod
    def _record(self, measurement: Measurement) -> typing.NoReturn:
        """ Inner abstract definition for Measurement object handling.

        :param measurement:
        """
        pass

    @classmethod
    def record(cls, measurement: Measurement) -> typing.NoReturn:
        """ Record a Measurement.

        :param measurement:
        """
        # Set default exporter target
        source_name = measurement.source.get_export_source_name()
        target_name = cls.MEASUREMENT_TARGET_DEFAULT

        with cls._measurement_metadata_lock:
            # Cache measurement
            cls._measurement_cache[measurement.get_source_hash()] = measurement

            # Remap exporter target if remap is set
            for pattern, new_target_name in cls._measurement_target_remap:
                if pattern.match(source_name) is not None:
                    target_name = new_target_name
                    break

            if target_name not in cls._measurement_target_list or len(cls._measurement_target_list[target_name]) == 0:
                raise MeasurementTargetRemappingException(f"Measurement source {source_name} has no valid targets")

            targets = cls._measurement_target_list[target_name]

        for target in targets:
            target._record(measurement)


class DummyTarget(LoggedAbstract, MeasurementTarget):
    """ A dumb target that just logs all Measurements received. Used for testing only."""

    def __init__(self):
        LoggedAbstract.__init__(self)
        MeasurementTarget.__init__(self)

    def _record(self, measurement: Measurement) -> typing.NoReturn:
        self.logger().info(measurement)


# Type hinting definitions for measurements
T_MEASUREMENT_SEQUENCE = typing.Sequence[Measurement]
T_MEASUREMENT_RETURN = typing.Union[Measurement, T_MEASUREMENT_SEQUENCE, T_FIELD_MAP]


# Basic dynamic fields
def dynamic_field_time_delta(initial_time: datetime) -> T_DYNAMIC_FIELD:
    def func(measurement: Measurement):
        return round((measurement.timestamp - initial_time).total_seconds(), 6)

    return func


class MeasurementGroup(enum.Enum):
    """ Definition for known types of hardware or measurements. """

    # Raw data
    RAW = 'raw'

    # Metadata
    EVENT = 'event'
    STATUS = 'status'

    # Gas flow
    MFC = 'mfc'

    # Calculated gas concentrations
    GAS = 'gas'

    # Gas combustion measurements
    COMBUSTION = 'combust'

    # Valves
    VALVE = 'valve'

    # Internal
    DEBUG = 'debug'

    # Motion
    ACCELERATION = 'acceleration'
    VELOCITY = 'velocity'
    POSITION = 'position'

    # Electrical measurements
    VOLTAGE = 'voltage'
    CURRENT = 'current'
    RESISTANCE = 'resistance'
    IMPEDANCE = 'impedance'
    POWER = 'power'

    # LCR
    CAPACITANCE = 'capacitance'
    INDUCTANCE = 'inductance'
    DISSIPATION = 'dissipation'
    QUALITY = 'quality'

    # Measure current, supply voltage
    CONDUCTOMETRIC_IV = 'conductometric_iv'

    # Measure voltage, supply current
    CONDUCTOMETRIC_VI = 'conductometric_vi'

    # Environmental conditions
    TEMPERATURE = 'temperature'
    HUMIDITY = 'humidity'

    # CV/CC power supply
    SUPPLY = 'supply'

    # Frequency
    FREQUENCY = 'frequency'
    PERIOD = 'period'

    # Complex signals
    TIME_DOMAIN_SAMPLE = 'timedomain'
    FREQUENCY_DOMAIN_SAMPLE = 'freqdomain'
    TIME_FREQUENCY_SAMPLE = 'tfdomain'

    # Particle counts
    PARTICLE_COUNT = 'pn'
    PARTICLE_MASS = 'pm'
