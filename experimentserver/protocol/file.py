import types
from collections import ChainMap

import yaml
from experimentlib.data.unit import registry, Quantity, converter, parse, parse_timedelta
from experimentlib.file.yaml import ConstructorError
from experimentlib.util import arg_helper
from experimentlib.util.generate import hex_str

import experimentserver
from .stage import BaseStage

HEADER = f"""%YAML 1.2
---
# Generated by {experimentserver.__app_name__} v{experimentserver.__version__}
# THIS FILE CONFORMS TO PROTOCOL VERSION 2, OLD PROTOCOLS MAY NOT WORK AND/OR CAUSE UNPREDICTABLE RESULTS
#
# This is a YAML file extended by Jinja2, allowing use of loops and subroutines.
#
# IMPORTANT: Proper indentation is critical to proper parsing. Use spaces to ensure file contents are properly alligned.
#
# NOTES:
#   - Anything beginning with a # is a comment and is ignored by the program.
#     You can use this to enable/disable certain functions.
#
#   - ALL EXPERIMENTS MUST DEFINE THE FOLLOWING TAGS UNDER THE "metadata" HEADER:
#       experiment: 'Unlabelled Experiment'
#       sample: 'Unlabelled Sample'
#     EXPERIMENTS USING AN LED SHOULD ADD:
#       led_current: '<current> mA'
#       led_optical_power: '<power> Î¼W'
#       led_wavelength: '<wavelength> nm'
#
#   - Many shortcuts exist to help write your procedure.
#     Note the command format and use of commas, arguments in square brackets [] are optional.
#
#     - !delay <time>[, <tag>=<value>, <tag>=<value>, ...]
#         Will wait the specified time before proceeding, can append additional metadata
#         eg:
#           - !delay 1 hour
#           - !delay 3 mins, this_is_a_tag=yes it is, another_tag=yes
#           - !delay 10 sec
#     
#     - !pause [<tag>=<value>, <tag>=<value>, ...]
#         Pause procedure, will wait forever until manually resumed, can append additional metadata
#         eg:
#           - !pause
#     
#     - !flow <mfc>, <flow rate>
#         Shortcut to set a flow rate
#     
#     - !stage <temperature OR ramp OR humidity OR valve>, <value>
#         Shortcut to change Linkam stage/generator settings
#         eg:
#           - !stage temperature, 30 degC
#           - !stage ramp, 10 degC/min
#           - !stage humidity, 30%
#           - !stage valve, vent
#           - !stage valve, chamber
#     
#     - !interlock
#         Shortcut to setup interlock for UV or high voltage use
#         eg:
#           - !interlock
#     
#     - !notify <message>
#         Send a notification via Pushover (requires paid app and special configuration)
#         eg:
#           - !notify Something has happened
#     
#     - !pulse <mfc>, <expose flow rate>, <exposure time>, <recovery time>
#         Optional arguments:
#           setup_time=<setup time>
#           balance_mfc=<mfc to use for balance gas, defaults to mfc_air_dry>
#           total_flow=<total flow rate for exposure, defaults to 200 sccm>
#           tags=<tag>=<value>, <tag>=<value>, ...
#           
#         EXPERIMENTAL NEW COMMAND Automatically calculates flow rate for specified gas.
#         
#         eg:
#           - !pulse mfc_hydrogen, 50 sccm, 30 secs, 1 hour
#           - !pulse mfc_hydrogen, 200 sccm, 1min, 10min, setup_time:10min, tags:expose_concentration=1%, expose_gas=Hydrogen
#     
#     - !set <hardware>, <command>[ <argument>, <argument>, ...]
#         Manual command, use with caution.
#

"""


class ProcedureArgumentError(experimentserver.ApplicationException):
    pass


class YAMLProcedureLoader(yaml.SafeLoader):
    # Argument parser for !set
    _SET_PARSER = arg_helper.SimpleArgParser()
    _SET_PARSER.add_argument('hardware')
    _SET_PARSER.add_argument('method')
    _SET_PARSER.add_argument('args', greedy=True, required=False)

    # Argument parser for !delay
    _DELAY_PARSER = arg_helper.SimpleArgParser()
    _DELAY_PARSER.add_argument('interval', converter=converter)
    _DELAY_PARSER.add_argument('tags', converter=arg_helper.parse_pair, default=[], greedy=True, required=False)

    # Argument parser for !pause
    _PAUSE_PARSER = arg_helper.SimpleArgParser()
    _PAUSE_PARSER.add_argument('tags', converter=arg_helper.parse_pair, default=[], greedy=True, required=False)

    # Argument parser for !stage
    _STAGE_PARSER = arg_helper.SimpleArgParser()
    _STAGE_PARSER.add_argument('type', converter='lower', values=['temperature', 'ramp', 'humidity', 'valve'])
    _STAGE_PARSER.add_argument('value')

    # Argument parser for !notify
    _NOTIFY_PARSER = arg_helper.SimpleArgParser()
    _NOTIFY_PARSER.add_argument('message', greedy=True)

    # Parser for !flow
    _FLOW_PARSER = arg_helper.SimpleArgParser()
    _FLOW_PARSER.add_argument('mfc')
    _FLOW_PARSER.add_argument('flow')

    # Parser for !pulse
    _PULSE_PARSER = arg_helper.SimpleArgParser()
    _PULSE_PARSER.add_argument('expose_mfc')
    _PULSE_PARSER.add_argument('expose_flow', converter=converter(registry.sccm))
    _PULSE_PARSER.add_argument('expose_time', converter=parse_timedelta)
    _PULSE_PARSER.add_argument('recover_time', converter=parse_timedelta)
    _PULSE_PARSER.add_argument('setup_time', required=False)
    _PULSE_PARSER.add_argument('balance_mfc', default='mfc_air_dry', required=False)
    _PULSE_PARSER.add_argument('total_flow', converter=converter(registry.sccm), default=Quantity(200, registry.sccm),
                               required=False)
    _PULSE_PARSER.add_argument('tags', converter=arg_helper.parse_pair, default=[], greedy=True, required=False)

    def __init__(self, stream):
        yaml.SafeLoader.__init__(self, stream)

    def _parse_node_args(self, parser: arg_helper.SimpleArgParser, node: yaml.ScalarNode) -> types.SimpleNamespace:
        try:
            return parser.parse(self.construct_scalar(node))
        except arg_helper.ArgumentError as exc:
            raise ConstructorError('Error parsing arguments to command', node) from exc

    def command_set(self, node: yaml.ScalarNode):
        args = self._parse_node_args(self._SET_PARSER, node)

        return {
            'class': 'core.Setup',
            'version': BaseStage.EXPORT_VERSION,
            'parameters': {
                args.hardware: {
                    args.method: ', '.join(args.args)
                }
            }
        }

    def command_delay(self, node):
        args = self._parse_node_args(self._DELAY_PARSER, node)
        tags = dict(ChainMap(*args.tags)) if len(args.tags) > 0 else {}

        return {
            'class': 'core.Delay',
            'version': BaseStage.EXPORT_VERSION,
            'interval': args.interval,
            'metadata': tags
        }

    def command_pause(self, node):
        args = self._parse_node_args(self._PAUSE_PARSER, node)
        tags = dict(ChainMap(*args.tags)) if args.tags else {}

        return {
            'class': 'core.Pause',
            'version': BaseStage.EXPORT_VERSION,
            'metadata': tags
        }

    def command_stage(self, node):
        args = self._parse_node_args(self._STAGE_PARSER, node)

        if args.type == 'temperature':
            return {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    'linkam': {
                        'set_temperature': args.value
                    }
                }
            }
        elif args.type == 'ramp':
            return {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    'linkam': {
                        'set_temperature_ramp': args.value
                    }
                }
            }
        elif args.type == 'humidity':
            return {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    'linkam': {
                        'set_humidity': args.value
                    }
                }
            }
        elif args.type == 'valve':
            valve_pos = args.value.lower()

            if valve_pos in ('a', 'chamber', 'sample'):
                valve_pos = 'A'
            elif valve_pos in ('b', 'vent'):
                valve_pos = 'B'
            else:
                raise ConstructorError(f"Invalid valve position \"{valve_pos}\"", node)

            return {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    'valve_humid': {
                        'set_position': valve_pos
                    }
                }
            }

    def command_notify(self, node):
        args = self._parse_node_args(self._NOTIFY_PARSER, node)

        return {
            'class': 'core.Notify',
            'version': BaseStage.EXPORT_VERSION,
            'message': args.message
        }

    def command_flow(self, node):
        args = self._parse_node_args(self._FLOW_PARSER, node)

        return {
            'class': 'core.Setup',
            'version': BaseStage.EXPORT_VERSION,
            'parameters': {
                args.mfc: {
                    'set_flow_rate': args.flow
                }
            }
        }

    def command_pulse(self, node):
        args = self._parse_node_args(self._PULSE_PARSER, node)
        tags = dict(ChainMap(*args.tags)) if args.tags else {}

        # Generate unique ID for exposure
        tags['expose_uid'] = hex_str()

        expose_flow = parse(args.expose_flow, registry.sccm)
        total_flow = parse(args.total_flow, registry.sccm)

        setup_tags = tags.copy()
        setup_tags['expose_phase'] = 'setup'

        expose_tags = tags.copy()
        expose_tags['expose_phase'] = 'expose'

        recover_tags = tags.copy()
        recover_tags['expose_phase'] = 'recover'

        if expose_flow > total_flow:
            raise ConstructorError(f"Pulse exposure flow of {expose_flow} exceeds total flow of {total_flow}", node)

        if args.setup_time is not None:
            pulse_sequence = [
                {
                    'class': 'core.Setup',
                    'version': BaseStage.EXPORT_VERSION,
                    'parameters': {
                        args.balance_mfc: {
                            'set_flow_rate': total_flow
                        }
                    }
                },
                {
                    'class': 'core.Setup',
                    'version': BaseStage.EXPORT_VERSION,
                    'parameters': {
                        args.expose_mfc: {
                            'set_flow_rate': 0
                        }
                    }
                },
                {
                    'class': 'core.Delay',
                    'version': BaseStage.EXPORT_VERSION,
                    'interval': args.setup_time,
                    'metadata': setup_tags
                }
            ]
        else:
            pulse_sequence = []

        pulse_sequence.extend([
            # Exposure
            {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    args.balance_mfc: {
                        'set_flow_rate': total_flow - expose_flow
                    }
                }
            },
            {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    args.expose_mfc: {
                        'set_flow_rate': expose_flow
                    }
                }
            },
            {
                'class': 'core.Delay',
                'version': BaseStage.EXPORT_VERSION,
                'interval': args.expose_time,
                'metadata': expose_tags
            },

            # Recovery
            {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    args.balance_mfc: {
                        'set_flow_rate': total_flow
                    }
                }
            },
            {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    args.expose_mfc: {
                        'set_flow_rate': 0
                    }
                }
            },
            {
                'class': 'core.Delay',
                'version': BaseStage.EXPORT_VERSION,
                'interval': args.recover_time,
                'metadata': recover_tags
            }
        ])

        return pulse_sequence

    def command_interlock(self, _):
        return [
            {
                'class': 'core.Setup',
                'version': BaseStage.EXPORT_VERSION,
                'parameters': {
                    'rigol': {
                        'set_voltage': (3, '5V'),
                        'set_current': (3, '1A'),
                        'set_output': (3, True)
                    }
                }
            }
        ]


YAMLProcedureLoader.add_constructor('!delay', YAMLProcedureLoader.command_delay)
YAMLProcedureLoader.add_constructor('!notify', YAMLProcedureLoader.command_notify)
YAMLProcedureLoader.add_constructor('!pause', YAMLProcedureLoader.command_pause)
YAMLProcedureLoader.add_constructor('!stage', YAMLProcedureLoader.command_stage)
YAMLProcedureLoader.add_constructor('!set', YAMLProcedureLoader.command_set)
YAMLProcedureLoader.add_constructor('!flow', YAMLProcedureLoader.command_flow)
YAMLProcedureLoader.add_constructor('!pulse', YAMLProcedureLoader.command_pulse)
YAMLProcedureLoader.add_constructor('!interlock', YAMLProcedureLoader.command_interlock)
